---
layout: post
title: "습격자 초라기 풀이"
date: 2021-11-11 21:41:00 +0900
categories: algorithm
---

블로그에 풀이를 쓰는게 시간은 걸리지만 재미가 있습니다. 
이번 문제는 [습격자 초라기](https://www.acmicpc.net/problem/1006) 입니다. 
처음 풀어보는 플래티넘 문제네요.

## 단순화

먼저 문제를 단순화합니다. 문제는 특수 소대의 최소 개수를 물었습니다. 특수 소대는 최대 2칸 까지 커버가 가능하니, 바꿔말하면 2칸 까지 커버 가능한 특수 소대의 최대 개수를 묻는 것과 동일합니다. 즉, 2칸짜리 타일을 배치하는 것과 동일합니다.

## 환형

문제는 `0`과 `N-1` 이 연결되어 있는 환형이라는 것입니다. 이를 단순화하는 방법이 여러가지 방법이 있을 것 같은데,
저는 `0` 부터 `N-2` 까지 반복문으로 계산하고 `0` 과 `N-1` 의 연결은 수동으로 연결해주었습니다.

## 상태

`n` 에서 타일을 최대한 채우면 `n+1` 에 4가지 상태가 발생할 수 있습니다.

![state](/img/습격자-초라기-풀이/습격자-초라기-풀이-state.svg)

## 점화식

n 이 증가함에 따라 변화는 다음과 같습니다. 그림에서 실선은 무조건 값이 이전되고, 점선은 2칸짜리 타일을 배치할 수 있으면 이전된다는 의미입니다.

![diagram](/img/습격자-초라기-풀이/습격자-초라기-풀이-diagram.svg)

위 도식을 파이썬 코드로 나타내면 아래와 같습니다.

{% highlight python %}
# A,B,C,D=0,1,2,3
상단배치가능 = areas[n][0] + areas[n+1][0] <= W
하단배치가능 = areas[n][1] + areas[n+1][1] <= W
세로배치가능 = areas[n][0] + areas[n][1] <= W

dp[n+1][A] = max(dp[n][A] + (1 if 세로배치가능 else 0), dp[n][B], dp[n][C], dp[n][D])
if 상단배치가능:
    dp[n+1][B] = max(dp[n][A] + 1, dp[n][C] + 1)
else:
    dp[n+1][B] = 0
if 하단배치가능:
    dp[n+1][C] = max(dp[n][A] + 1, dp[n][B] + 1)
else:
    dp[n+1][C] = 0
dp[n+1][D] = (dp[n][A] + 2) if 하단배치가능 and 상단배치가능 else 0
{% endhighlight %}

## 초기상태
위 점화식을 `N-1` 의 배치에 따라 5가지 초기상태로 두고 `0` 부터 `N-2` 까지 반복합니다. 
초기상태마다 쓸 수 있는 공간이 제한되어 있습니다. 노란색이 각 초기상태마다 쓸 수 있는 마지막 공간입니다.

![start](/img/습격자-초라기-풀이/습격자-초라기-풀이-start.svg)